\section{总结与感想}

\subsection{核心收获}
通过从单机回环到应用层管理工具的六个递进实验，本课程设计完整走了一遍从物理层到应用层的实现路径，直观体会了分层解耦、协议设计和状态维护在网络通信中的重要作用。实验一的单机回环通信使我们掌握了串口配置、数据收发与缓冲区管理的基本技能，建立了对物理层与数据链路层的直观认识。实验二的双机 C/S 通信引入了应用层协议的概念，通过命令解析与响应机制体会了协议设计的灵活性与可扩展性。实验三的树形拓扑多机通信实现了基于 ID 的帧转发，初步建立了网络层寻址与转发的概念。实验四的距离向量路由算法是整个课程设计的核心，通过 Bellman-Ford 方程、毒性逆转与邻居超时检测等机制，深刻理解了分布式路由的工作原理与自适应能力，亲手实现了路由表的动态收敛、链路故障检测与路由恢复。实验五的停等可靠传输协议引入了 CRC32 校验、超时重传与会话建立机制，体会了运输层在端到端可靠通信中的关键作用，同时通过故意注入错误与丢包验证了协议的鲁棒性。实验六的 ICMP 与网络管理工具将理论知识转化为实用工具，ping 和 traceroute 的实现加深了对 TTL、ICMP 报文与多跳转发的理解，可视化上报与远程控制则通过 FastAPI 后端与 React 前端形成闭环，展示了应用层在网络管理中的可视化与远程协同价值。整个实验过程中，串口通信的粘包/分包处理、距离向量的收敛过程、停等协议的重传机制、TTL 递减与 ICMP 报文的生成解析等知识在实践中得到巩固，Python 多线程编程、事件同步与并发控制的工程能力也得到了显著提升。

\subsection{问题与解决方案}
实验过程中遇到了若干典型问题，通过分析与调试逐一解决，积累了宝贵的工程经验。串口粘包与半包问题在实验初期频繁出现，尤其是在高速率或长消息场景下，接收端可能一次读取多个完整帧或半个帧，导致解析错误。解决方案是统一采用换行符作为分帧边界，接收线程内部使用 \texttt{readline()} 或累积读取直到遇到完整的换行符，确保每次解析的都是完整的帧，必要时在接收端维护缓冲区以处理半包情况。路由环路与路由失效问题在实验四初期较为突出，未实现毒性逆转时，某些拓扑下会出现路由环路导致数据包无限转发，未实现邻居超时检测时，链路断开后路由表仍保留过时路由导致黑洞。解决方案是在距离向量通告中加入毒性逆转逻辑，向邻居通告时若某目的的下一跳是该邻居则谎报开销为 999，从根本上避免环路；同时实现邻居超时检测机制，10 秒内未收到 HELLO 则移除邻居并将相关路由开销置为 999，触发 DV 更新以通知全网。可靠传输的丢包与误码恢复在实验五中通过停等协议配合 CRC32 校验与超时重传得到验证，即使模拟篡改或丢包也能最终恢复或在达到最大重试次数后超时放弃，避免永久阻塞。串口拔插异常在多次实验中导致程序崩溃或残留后台线程，解决方案是在所有串口写入操作前检查串口状态，写入失败时捕获异常并关闭该端口，同时从邻居表与转发表中移除对应条目，确保程序鲁棒性。

\subsection{改进建议与展望}
基于当前实验的实现与测试，提出若干改进建议与未来展望，以进一步提升系统的性能与实用性。路由算法方面，当前的距离向量算法在小规模拓扑下表现良好，但在大规模拓扑下收敛时间较长且开销较大，可以扩展为链路状态算法（如 OSPF），每个节点维护全网拓扑并独立计算最短路径，收敛速度更快且支持更复杂的拓扑结构，同时可以引入度量加权（如带宽、延迟）以支持更灵活的路由策略。可靠传输方面，当前的停等协议吞吐受 RTT 限制，每次发送后必须等待 ACK 才能发送下一帧，效率较低，可以升级为滑动窗口协议（Go-Back-N 或 Selective Repeat），发送端可以连续发送多个帧而无需逐个等待 ACK，显著提高吞吐量并减少等待时间，同时支持流量控制与拥塞控制机制。应用层工具方面，当前的 ping 和 traceroute 已经实现了基本功能，可以进一步增加文件传输工具（如基于可靠传输的 FTP）、节点监控面板（实时显示 CPU、内存、端口状态）等实用功能，同时完善 Web 端可视化的安全认证机制（如 JWT）与数据持久化（如数据库存储历史路由表与日志），提升系统的实用性与安全性。所有实验源代码与报告已同步至 GitHub 仓库（\url{https://github.com/Spercent521/network-curriculum_design-CUG}），便于复现与进一步改进，欢迎其他同学与开发者参考与贡献代码。
